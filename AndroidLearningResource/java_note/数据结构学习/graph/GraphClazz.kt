/**
 *  Created by jixiaoyong1995@gmail.com
 *  Data: 2018/12/25.
 *  Description:图
 *  由顶点 边 组成
 *  树有两种表示形式：
 *  1. 邻接矩阵
 *      一个n * n的数组。1-两个顶点邻接 ，0-两个顶点不邻接
 *      比如，m和n邻接，则需要更新arr[m][n]和arr[n][m]为1
 *  2. 领接表
 *      一个保存有n个链表的数组，每个链表保存和这些点邻接的顶点
 *
 *  两种搜索方式：
 *  1. 深度优先搜索（DFS）
 *      用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次
 *      规则：
 *      1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；
 *      2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点；
 *      3/3 1,2都无法满足时，搜索结束；
 *  2. 广度优先搜索（BFS）
 *      用队列实现，会先遍历完本层所有的顶点，然后再移向下一层
 *      规则：
 *      1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列
 *      2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1
 *      3/3 如果2不能满足，搜索结束
 *
 *
 *  # 最小生成树MST
 *  > 生成树（Template:Lang-en-short）是具有 G 的全部顶点，但边数最少的连通子图.
 *
 *  带权图的生成树中，总权重最小的称为最小生成树。最小生成树边比顶点树小1
 *  当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。
 *  如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。
 *
 *  无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现
 *
 *
 *  # 拓扑排序
 */
class GraphClazz {
}