1.经验

	1）写程序可以写备注，方便以后使用：

	――――在程序头输入――――
	/*
		时间：2016年3月16日 16:41:07
		目的：
		功能：
	*/

	――――在程序后输入――――
	/*
		程序在VC++6.0的输出结果：
			******
	*/


	2）分析程序：

		先看流程	每个语句的功能		试数

	3)代码对齐

	Ctrl + A , Alt + F8

	shift + tab也可以

	4）人没有能力就没有尊严

	5）建立一个项目需要掌握的：

		Java SE；Java web；数据库―界面

		项目需要：界面（简单） <――> 数据库（厉害）
					按钮

		后台：按钮和数据库连接用 Java SE 和 Java Web



2.杂类


	1）内存条内的数值是0101010100100100101001011等等

	2）不含有;则是表达式，含有;为语句

	3）i++和++i的区别

		其意义都是i=i+1

		i++：先引用i的值，再进行i+1

		++i：先进行i+1，再引用i的值

		――――――――――――――――

		例子：

		int i=1,sum=1,m,n;

		m=(i++);
		n=(++sum);

		printf("i=%d,sum=%d\n",i,sum);
		printf("m=(i++)=%d,n=(++sum)=%d\n",m,n);

		――――――――――――――――

		结果：	i=2,sum=2
			m=(i++)=1,n=(++sum)=2

		――――――――――――――――

	4)强制类型转换

	格式：(数据类型)(表达式)
		（float)(i）

	功能：将表达式的值强制转化为指定的数据类型

	5）浮点数存储问题

	float和double都不能保证精确的存储小数

	――――――――――――――――――――
	面试问题：如何判断浮点型变量x是否为0

		if(x)
			printf ("x不是0" );
		else printf ("x是0");

	【原先提法】――――――――――――

		if（|x-0.000001|<0.000001）	//这样子算的话仍然有误差
			printf ("x is zero ");
		else printf ("x is not zero ");


		
		―72-for循环-浮点存储所带来的问题―

	――――――――――――――――――――――

	6）常用缩写

		cnt	个数；
		avg	平均数；

	7）顺序点

		有三个，在顺序点之前的操作在顺序点之后要立即生效

		,	;	()

	8）推荐的书

	《turboc2.0 实用大全》 机械工业出版社


3.数据类型


  整数
	整型	int		4
	短整型	short int	2
	长整型	long int	8

 浮点数
	单精度浮点数	float	4
	双精度浮点数	double	8

  字符
			char	1

  复合数据类型
	结构体
	枚举

4.变量--本质是内存中的一段存储空间


 1）变量赋值时存放在内存中，程序终止后，变量所占空间被释放

 2）定义变量时系统指定一段内存空间

 3）赋值后，变量所对应的内存空间相应改变


5.变量为什么要初始化（赋值）


 1）变量未初始化的时候，输出的值是VC++自动添加的“添充字”，提示当前变量未赋值。

 2）内存释放是解除对内存的使用权限，而不是清除内存值，内存中可能还有以前软件的遗留数值，称为垃圾值

 3）软件运行过程：软件向系统请求内存――系统分配内存，软件运行――软件运行期间，软件所占内存不在分配给其他软件――软件结束后，操作系统回收内存（操作系统并不清除内存中数据）

6.定义变量


 1)	数据类型 变量名 = 要赋的值；

 2）	数据类型 变量名；
	变量名=要赋的值；

7.进制


	1）N进制就是逢N进一

	110就是 1*2的（3-1）次方+1*2的（2-1）次方+0*2的（1-1）次方=6

	（1566）6	数字括号右下标为6表示为6进制

	2）printf用法：

	%d		以十进制输出
	%x或%X		以十六进制输出
	%c		输出字符变量

	3）进制转化

		[1]十进制转化为N进制：十进制数字对N取余数，将余数倒排列

		―――――――――――――――――――――

			十进制转化为2进制

			十进制数字对2取余数，将所有得到的余数倒过来即是二进制
			如：182――（10111001）2

		――――――――――――――――――――――

		[2]N进制转化为十进制：（N进制数字第I位数字*N的（I-1）次方）之和就是对应的十进制

		――――――――――――――――――――――

		五进制的数字：235
		对应的十进制数字：2*5^（3-1）+3*5^（2-1）+5*5^（1-1）=2*25+3*5+5*1=70

		――――――――――――――――――――――

	4）不同进制所代表的数字之间的关系

		代表的数值是一样的 //自己的体会


8.常量


  整数
	十进制		传统写法
	十六进制	前面加0x或者0X
	八进制	前面加0(数字零，而非o)

 浮点数
	传统写法
		float x = 3.2； //传统写法
	科学计数法
		float x = 3.2e3；	//x值为3200
		float x = 123.5e-2；	//x值为1.235

	数字后面加F，转化为float型，否则为double型

  字符
	单个字符用单引号括起来''
	'A'		对
	'AB'		错
	"AB"		对

	字符串用双引号括起来""
	"A"		对，相当于'A'和'\0'组合，是字符串，不能赋值给单个字符串
	"BA"		对，是字符串，不能赋值给单个字符串

9.常量以怎样的二进制代码存放在计算机中？[了解]


	常量		存放形式
	――――――――――――
	整数，字符	补码
	实数		IEEE754标准

	之后在转化为二进制存放在计算机中

	字符――>ASCII码――>补码――>二进制

10.代码规范化


	《高质量c编程》林锐


	一般程序框架：

	# include <stdio.h>

	int main (void)
	{
	
		return 0;
	}


	成对代码成对敲；
	不同级缩进同级对齐；
	代码功能独立则换行；

11.字节


	字节是存储数据的单位，是硬件所能访问的最小单位

	1字节 = 8位
	1K = 1024字节
	1M=1024K

12.不同类型数据相互赋值


	【需要利用补码知识】

13.ASCII


	ASCII是一种规则，规定了不同的字符和整数一一对应，并不是数值

	'A'  ―― 65
	'a'  ―― 97

	由此可见字符的存储方式本质上和整数的存储方式相同

14.基本输入和输出printf（）和scanf（）


	1）键盘输入	scanf（）
		用法：
		（1）scanf("输入控制符",&输入参数);

			输入控制符的作用是将从键盘输入的字符转换位指定格式
		（2）scanf（"非输入控制符 输入控制符",&输入参数）;

			a.含有非输入控制符时，必须在输入的时候输入非输入控制符，再输入输入控制符控制的数值
			b.如果在输入控制符控制的输入值后再输入非输入控制符，则将只识别输入控制符控制的值，其他的不输入
			c.非输入控制符在输入时必须原样输入

			――――――――――――――――
			如scanf("m%d",&i);

				则输入m123正确，识别123

				输入m123n只识别123
			――――――――――――――――
		（3）scanf（）最好不要有非输入控制符，\n等
		（4）跳过非法输入值，正确录入数据

			――――――――――――――――
			char ch;
			while((ch=getchar())!='\n')	//等待用户输入，判断是否是换行符
				continue ;	//继续读取，作用是等到输入回车时给i赋值
			scanf("%d",&i);
			――――――――――――――――

	2）屏幕输出	printf("输出控制符",输出值);

		输出控制符：%d 表示将变量以10进制输出	变量本身是以二进制存放的
		输出控制符		功能
		――――――――――――――
		%d			int
		%ld			long int
		%c			char 
		%f			float 
		%lf			double
		%o			同十六进制格式
		%s			字符串

		――――输出十六进制――――以47为例
		――int ，long int， short int ――

		%x			2f
		%X			2F
		%#x			0x2f
		%#X			0X2F（推荐）

		――――――END――――――


15.运算符

	算数运算符
		+	-	*	/	%（取余数）

	关系运算符
		>	>=	<	<=	!=	==

	逻辑运算符
		！	&&	||

	赋值运算符
		=	+=	*=	/=	-=

		――――――优先级别―――――

			算数>关系>逻辑>赋值

		―――――――END―――――――



	1）/除法	m/n
		m，n都是整数，则商为整数，有小数的截取掉，否则为小数

	2）%取余	m%n
		余数只与m的正负有关
		m，n必须为整数

	3）非0为真
		如果为真，用1表示；如果为假，用0表示。

		――――――――――――――――――

		（1）	m=（3>2）&&（8）

			（3>2）为真；8非0，是真
		原式相当于真&&真，m为真，故m==1

		（2）	m=（1>2）&&（k=8）

		（1>2）为假，&&右边（k=8）不执行
			故而m=0，k未赋值

		（3）	m=（1<2）||（k=8）

		（1<2）为真，||右边（k=8）不执行
		故而m=1，k未赋值，反之左边为假，右边才执行


		――――――――END―――――――

	4)琐碎的知识（用的少）

	自增/减		三目运算符	逗号表达式

		[1]自增
			前自增	++i	整体表达式的值是i+1之后的值	先加1，再赋值
			后自增	i++	整体表达式的值是i+1之前的值	先赋值，再加1

			――――――注意事项――――――

			1.编程应当尽量避免前自增和后自增的区别；

			2.自增表达式，最好作为单独的一个语句；
			不要作为复合表达式的一部分来使用；

			――――――――END―――――――

		[2]三目运算符

			A ? B : C ;

			等价于if(A) B;else C;

		[3]逗号表达式

			A,B,C;

			功能：	从左到右，顺序执行

				最终表达式的值为最后一项（C）的值



16.流程控制【重点】

	1）定义

		程序执行代码的顺序


	2）分类

		（1）顺序执行

		（2）选择执行
			a.定义

				有选择性的执行某些代码

			b.分类

				if

			――――――――――――――
			[1]if简单用法

			格式：
			if(条件)
				printf("满足条件，执行语句");

			功能：
			如果条件为真，执行语句

			[2]if的范围

			if的控制范围是条件后面的第一个语句
			如果需要控制多个语句，可以用{ }括住多个语句

			[3]if...else...

			if(条件)
				语句1;
			else
				语句2;

			――条件为真，执行语句1,否则执行语句2――

			[4]if...else if ...else 

			if(条件1)
				语句;

			else if(条件2)
				语句2;

			else 	语句3;
			
			――――特殊――――

			if(条件1)
				语句1;
				语句*; //此语句*插入使得其后的else无效

			else if(条件2)
				语句2;

			else 	语句3;

			―――――END―――――
			

			[5]C语言对真假的处理

			0为假，非0为真

			[6]举例――求分数的等级

			#include<stdio.h>

			int main (void)
			{
				float score;

				printf ("input your score(0~100)");
				scanf ("%f",&score);

				if (score >100||score <0)
					printf ("error\n");
				else if (score >=90)
					printf ("best\n");
				else if (score >=80)
					printf ("good\n");
				else if (score >=60)
					printf ("not bad\n");
				else
					printf ("bad\n");

			}

			//(90<=score<=100),无论score 大于或小于90，返回的值0（假），1（真），都小于100，所以这个式子永远都为真，值为1


			[7]常见问题

			*互换数字（i，j）

				k = i,i = j,j = k;

			*三个数字求最大值（i，j，k）

			 
			*空语句

			if (条件) ;
				// if后面是空语句，“;”

			例：if(条件);	//此处有一个空语句
				语句1;
			    else 	//else前面没有对应的if，程序编译到此出错
				语句2;


			*else 后面不能再有条件表达式

				要么去掉条件表达式，要么加if

				如果加;则编译无问题，但是语句无意义，逻辑错误





			――――――――――――――


			[8]switch(不常用)

			switch在其里面找到和val值相等的入口并执行相关语句，直到遇到break，或者程序结束

			格式：
			switch(表达式)
			{
				case 常量表达式：语句1；

					……
			}

			用法：
				[1]常量表达式只能是1.枚举常量；2.数值常量；3字符常量；4.常常量；5.宏名的一种。普通变量，枚举变量是不能作为标签使用的

				[2]switch(表达式)中表达式可以是任意类型，但是VC++中只允许为int或者char型

				[3]执行完case后，流程会继续转到下一个case上继续执行。case只是起到语句标号的作用，在执行switch语句时，找到匹配的case语句后，会一直执行下去，而不会再判断。default之后不再执行。

				[4]switch是选择而不是循环，出现了break时，退出switch语句

			―――――――――――――――――――――――――
				int val;
				scanf ("%d",&val);

				switch (val)
				{
					case 1: printf ("hello 1");break ;
					case 2: printf ("hello 2");break ;
					case 3: printf ("hello 3");break ;
					case 4: printf ("hello 4");break ;
					default：break；
				}

				输入的val是2时，输出hello 2,并且退出（break）


			――――――――――END――――――――――――

			[9]break 和continue 的用法

				break ：
					用于终止循环或者switch；

					不能直接用于if，除非if属于循环内部的语句

					――――――――――――――――

					for(i = 1;i < 3; i++)
						{
							if( 3 > 2)
								break ;

						}
					//break 虽然是if中的语句，但是终止的是for循环

					//break只能终止离他最近的一个循环

					――――――――END――――――


				continue ：

					用于跳过本循环余下的语句，转至判断是否需要执行下次循环
					//忽略本次循环余下语句，直接进入下一次循环过程


				scanf中忽略非法输入

		（3）循环执行

			[1]定义

				某些代码被重复执行

			[2]分类

			for ――――――――――

			格式：for (表达式1;条件;表达式2)
					表达式3;

			流程：表达式1――条件判断――表达式3――表达式2――条件判断――表达式3――……――条件判断（为假）――退出循环

			注意事项：表达式2（更新部分），不能用浮点型定义，因为这个数据类型不能精确存储某些数据


			/* 求1+2+3+……+100值 */

			for (i = 1,sum = 0; i < 101; i++)
				sum = i+ sum ;

			//先执行i = 1,sum = 0,再判断i < 101，成立则执行sum = sum + i和i++，然后再判断i < 101，成立则继续循环，否则退出循环



			/* 求1~10中奇数之和 */

			for (i = 1,sum = 0; i < 10; i + = 2) //i+=2等价于i = i + 2
				sum = i + sum ;


			/* 求1~100之间可以被3整除的数之和 */

			for(i = 3, sum = 0, i < 100; i++)
				{

					if (i % 3 == 0)
						sum = i + sum; 

				}



			/* 求1~100间奇数的平均值 */

			for(i = 1; i < 100; ++ i)
			{
				if (i % 2 == 1)
					sum += i ,++cnt ;

			}
			avg= 1.0*sum / cnt;	1.0默认为double
			printf ("%f",avg);

				――――代码――――


					#include<stdio.h>

					int main (void)
					{
						int i = 1,sum = 0,cnt = 0 ;	//注意一定要给sum和cnt初始化，否则会出错
						float avg = 0 ;

						for(i = 1; i < 100; ++ i)
						{
							if (i % 2 == 1)
							sum += i ,++cnt ;

						}

						avg= 1.0 * sum / cnt;
						printf ("sum :%d cnt:%d \n ",sum ,cnt );
						printf ("avg：%f\n ",avg);

					}

				―――运行结果―――

				sum :2500 cnt:50
 				avg：50.000000
				――――END――――



			while――――――――――

				while (条件)
					语句;

				/* 执行顺序 */

					条件为真时执行语句


				/* 与for比较 */


					for比while语句逻辑更加清楚；更加不易出错

				/* 举例 */

				判断数字是否为回文数

				――――――――――――――


				#include<stdio.h>

				int main (void)
				{
					int val; //input the number
					int m , sum=0;

					printf("please input the number:");
					scanf("%d",&val);

					m = val;
					while (m)
					{
						sum = sum * 10 + m%10;
						m /= 10;
					}

					//这个的作用是把数字VAL倒置，然后再与val比较，如果二者相等，则val就是回文数
	
					if(sum == val)
						printf("Yes\n");
					else printf("No\n");
				}


				――――――――――――――


				/* for和while */

				for和while可以相互转换；
				但是do……while和while一定可以互换


			do...while――――――――

			格式：	do{ 语句 }while(条件);

			特点：	先执行语句，再判断是否符合条件

				主要用于人机交互

				――――――――――――――
					char ch ;
					printf("你想继续吗（Y/N）");
					scanf (" %c",%ch ); //%c前面必须加一个空格，原因略

					do{ 循环体 }
						while('y' == ch||'Y' == ch);

				――――――END―――――――


			[3]break和continue
 


17.数组

	1）定义：	数据类型 A[N] = {1,2,3,……,N};

	2）元素有N个，从A[0],A[1]到A[N-1]

	3）用途：处理大量同类型数据的存储和使用问题

		模拟现实世界

	4）分类：

		一维数组

			（1）数组元素连续分配存储空间

			（2）所有变量数据类型必须相同

			（3）所有变量所占字节大小必须相等

			（4）操作

				[1]初始化

					完全初始化	int a[5]={1,2，3,4,5};

					不完全初始化，未初始化元素为0	int a[5]={1,2，3};

					不初始化，所有元素为垃圾值	int a[5];

					清零	int a[5]={0};

					――――错误写法――――

					int a[5];	a[5] = {1,2,3,4,5};	//错误，只有在定义数组时才能给数组整体赋值，其他时候都是错误的

					int a[5] = {1,2,3,4,5};	a[5] = 100;//错误，没有a[5]这个元素

					int a[5]={1,2,3,4,5},b[5];

					把a数组元素全部赋给b数组：a = b;//错误，a，b代表的是数组的地址，而非所有数组元素

					――――――END――――

				[2]赋值，排序，求最大最小值，倒置，插入，删除



		二维数组


			（1）int a[3][4]={
					{1,2,3,4},
					{5,6,7,8},
					{9,10,11,12},
					 };

			（2）输出数组：

				for（i = 0;i < 3;++i）
				{ for (j = 0;j < 4; ++j ) 
					printf ("a[i][j] = %-5d" ,a[i][j]);//右对齐，每个元素占五格
				printf("\n"); //每输出一行，打印一个回车
					
				 }	


		多维数组

			是否存在多维数
组？
				不存在，因为内存是线性一维的，每个N维数组可以分成N-1维数组的一维数组


18.函数（重点）

	1）作用

	可以精简代码，解决大量同类型问题

	避免重复性操作

	有利于程序模块化

	2）定义

		（1）逻辑上：可以完成特定功能的独立代码块

			int f(void){函数内容}	//void表示该函数不能接收数据，int表示该函数返回值是整型的

		（2）物理上：可以接收数据，并在处理后将结果返回，相当于黑匣子

		（3）格式：

			函数返回值类型 函数名称（形参列表）
			{
				函数的执行体
			}

		（4）return ;和break;

			return终止函数，如果有返回值则返回某一值，如函数返回值类型为void，则不返回值

			break终止某一循环或者switch

		（5）函数返回值类型也称为函数的类型，如果函数返回值类型与return();表达式返回值不同，最终函数返回值以函数返回值类型为准

		（6）

	3）分类

	有参函数 和 无参函数

	有返回值 和 无返回值函数

	库函数 和 用户自定义函数

	值传递函数 和 地址传递函数

	普通函数（可以没有） 和 main函数（有且只有一个）
		main函数可以调用普通函数，但是普通函数无法调用main函数
		普通函数可以相互调用
		main函数是程序的入口和出口

	4）问题

	（1）函数的声明：

		在调用函数之前，添加“ 函数类型 函数名（形参）；”

		函数调用在函数定义之前的话，必须先声明函数

		函数声明是一个语句，必须有分号‘;’

		对于库函数的引用用“ #include<库函数所在文件的名称.h>”实现
	
	
	（2）形参和实参：
			个数相同，类型一致，位置对应


		int f(int i )	// int i 是形参
		{
			函数体
		}

		int main（）
		{
			i=f(5);	// 5 是实参
			……
		}
	（3）如何在软件开发中合理的设计函数解决函数问题

	函数的功能最好能精简，一个函数完成一个功能，这样子可以多次使用

		――――――――――――――――
	

		int ispriem(int val)	//判断val是否为素数，注意i是从2开始！
		{
			int i;

			for(i = 2; i < val; i++)
			{
				if(val%i == 0)
					break;
			}

			if(val == i)
				return 1;
			else return 0;
		}


		――――――――――――――――

		函数是C语言的基本单位

	5）系统函数

	double sqrt(double x);	//求x的平方根，返回double类型

	int abs(int x);	//求x的绝对值，返回整数类型

	double fabs(double x); //求x的绝对值，double类型
	

	6）递归

	必须有“栈”的概念：一个口进出，先进后出

		压栈：数据录入	； 出栈：数据输出




19.变量的作用于和存储方式

	分类：

	按作用域分类：

		全局变量

			在所有函数外部定义的函数，可以在其定义之后的所有函数中使用

		局部变量

			函数内部定义的变量或者函数形参，在本函数内部使用

		全局变量和局部变量命名冲突问题：

		――――――――――――――――――

		int i = 99；	//全局变量i
		void fun（int i）	//局部变量i
		{
			……
		}

		//局部变量和全局变量冲突，以局部变量为准

		――――――――――――――――――

		在VC++中，如果全局变量和局部变量定义相互冲突时，局部变量起作用

	按照变量的存储方式分类（后面应用不大）：

		静态变量

		自动变量

		寄存器变量


19.指针（重点）


  1）指针定义：

  指针就是内存单元的编号（值），指针就是地址，地址就是指针

  地址是内存单位的编号

  指针变量是存放地址的变量

  指针和指针变量不同，是两个概念，但通常会把 指针变量 简称 指针

	――――――――――――――――――

	指针定义：int *p;	// int *  表示p变量存放的地址是int类型
					p 的数据类型是 int * 类型 

	指针赋值：int i = 3； p = &i；	// p是一个int型指针，只能存储int变量的地址

	指针初始化：int i = 3，* p = &i； //p是int i 类型，p的值是i 的地址

	*p 完全等同于 i；i 和 *p 可以相互替换  *p完全等同于i

	变量指针 p 只能存放地址，p 指向 i；

	p 不是 i，i 也不是 p，更改p 或 i 的值，不会影响对方的值

	*p 是以p 的内容为地址的变量

		――――――*――――――

	地址：
		内存单元的编号

		从0开始的非负整数

		范围：0 ~ 4G-1


		――――*――――

		CPU到内存条之间由三条线控制：

		地址线，控制线，数据线

		地址线 确定内存条中的块

			地址线 到 内存条 有32条线,每条线有0,1两种状态，有2（32次方）b = 4G	故而内存条一般为4G大小

		――――――*――――――

	指针：

		指针就是地址，地址就是指针

		指针变量就是存放内存单元编号的变量

		指针不可以相互+/*，但可以-

		指针变量才是变量，才可以存数据，但指针变量常常简称指针，但二者概念不同

	――――――――――――――――――

  2）指针功能：

	表示一些复杂的数据结构

	*|快速的传递数据，减少内存耗用

	*|使函数返回一个以上的值

	能直接访问硬件

	能够方便的处理字符串

	是理解面向对象语言中引用的基础


  3）指针分类

	（1）基本类型指针

		int * p; // p 是变量的值变量类型是 int *

		地址不能互换，程序运行的时候修改的只是变量的值

	常见错误：

		――|

			int * p;  int i = 5;  *p = i;printf("%d",*p); 

			//无语法错误，不会报错，错误在于，p指向的是垃圾值，而不是指向i，是错误的，需要先给p指向一个地址

		――|	

			int i = 5； int *p； int *q； p = &i; *q = p;

			 //会报错，*q 是 int * 类型，而 p 是 int 类型，无法直接赋值

			//定义的时候，给q分配了内存，属于本程序，可以读写，但是如果q是垃圾值，*q并没有确定，本程序没有权限读写，会出错，

			//同时，p = q； 如果 q 是垃圾值，则 p 也成了垃圾值

			――――――――――――

			互换两个数字：

			int huhuan0(int a ,int b)
				{
					int t ;

					t = a,a  = b, b = a ; //此处a，b改变的是局部变量中a，b的值，与主函数中a，b没有关系，故而不能改变main函数中a，b的值

					return ;
				}


			 int huhuan1 (int *a,int *b)
			{
				int *p ; //p 必须和形参a，b类型相同才可以赋值

				 p = a , a = b ;b = q; //只是修改了形参a ，b 的内容，而非main函数中a，b的地址，main函数中a，b的值仍然没有互换

						//此句更换的是huhuan1函数形参a ，b 的值，从而使得*a 和 *b不再指向main函数中的a，b

				return ;


			}


			 int huhuan2 (int *a,int *b)
			{
				int p ; //p 必须和形参a，b类型相同才可以赋值

				 p = *a , *a = *b ，*b = q; //*a 和 *b是main函数中a ，b，为int类型,这个语句的功能是修改main函数中的a ，b的值，如果没有指针，则一次只能修改一个数值

				return ;


			}


			int main (void)
			{
				int a = 3 ,b = 5;

				huhuan0 (a, b);

				huhuan1 (&a,&b); //huhuan1中的形参a，
是地址

				huhuan2（&a ，&b）;

				printf ("a = %d b = %d",a ,b );

			}


			函数声明的时候一般不写形参或者形参可以和函数定义的形参不同


				――――――――――

				指针可以使函数返回一个以上的值，主要是借助于 int * p = i；*p 等价于i 来实现的，p里面存放的是i的地址，修改的还是*p对应的地址的值（即i的值）

				――――――――――

			通过被调函数修改主调函数普通变量的值：

				实参必须为改普通变量的地址；

				形参必须为指针变量；

				在被调函数中，通过 *形参名…… 修改主调函数的值

			――――――――――――


			* 的三种含义：

			a. 乘法

			b.定义指针变量

				int * p; 

				//定义了一个叫做p的变量，表示只能存放一个int类型的地址

			c.指针运算符

				在已经定义好的指针变量前面

				如 *p 表示以p 的内容为地址的变量

	（2）指针和数组

		[1]指针和一维数组

			a.数组名

			a[i][j] 表示第i+1行第j+1列的元素

			数组是连续的

			a[6] 一维数组名是指针常量，存放的是数组第一个元素的地址，是一个常量，不能改变值

				――――――――

				int a[6];

				printf ("a[0]地址：%#X \n a的值： %#X\n",&a[0],a);	// %#X 意思是以16进制输出结果

				――输出结果：

				a[0]地址：0X19FF28
				a的值： 0X19FF28
				
				――――――――


			b.下标和指针的关系

			函数需要调用一个数组需要知道数组首地址和数组的元素数目
				――――――――

				main函数中定义一个数组a[6]:

				int fun(int * p,int N)

				main调用fun时格式：fun（a，6）；

				――――――――

			*（p + i）等价于 p[i] 也等价于 a[i] ,亦等价于*（a + i）

			c.指针变量的运算

			指针变量不能/*+

			两个指针式同一块连续空间不同单元时，才可以相互-，相当于两个指针在同一个数组，其意义是两者相隔的单元数


			指针变量占用字节：4字节

				1个字节对应1个编号，对应八个010...

			数据类型|所占字节|对应指针
			char	|1	 |	4
			int	|4	 |	4
			double	|8	 |	4

			x占8个字节，第一个字节的编号代表x，


	――――――――――――――――――――――――

	||动态内存分配：

		1.传统数组的缺点：

		* 数组长度必须事先指定，且必须是长整数，不能是变量

			如：	int a[5];//OK
				int len = 5;int a[len] ; //error

		* 传统数组内存无法手动释放，除非该函数终止

			数组一旦定义，系统就会为其分配存储空间，并一直持续到该函数终止后，系统自动释放

		* 数组长度无法动态的调整

		* A函数定义的数组在其运行期间可以被其他函数使用，但其运行完毕后，A函数中的数组无法被其他函数调用

			――――――――

			void g（int *）{ …… }

			void f（）{ ……

				int a[3] = {1,2,3};

				g（a）; //在f函数运行的时候，g函数可以访问f函数中的数组a[3]，但是，但f函数终止之后，g函数无法访问a[3]

				}

			传统数组（静态数组）无法跨函数使用
			――――――――
		

		2.为什么需要：

		* 动态内存解决了以上问题

		3.举例：

	――――――――――――――――――――

	―― malloc 是memory allocate（内存 分配）的缩写

	#include <malloc.h>

	int *p = (int *)malloc(4);

		//请求系统为本程序分配4个字节，malloc只能返回第一个字节的地址

		//（int *） 的含义是将malloc返回的地址 强制类型转化 为整型地址

		//4就是动态分配的内存：4个字节，这行代码总共分配了4（p指针占用的，静态分配的）+4（系统动态分配的）个字节

		//malloc函数只有一个形参，且为整型

	free(p);	//把p指向的内存（动态分配的4个字节）释放掉

			//pArr 指向的是4个字节，pArr + 1 指向的则是后4个字节，如果 pArr 指向的是99个字节，则 pArr+1 指向的是后99个字节

	――――――――――――――

/*
2016年3月19日 15:11:55
动态内存定义一个一维数组
*/


#include<stdio.h>
#include<malloc.h>

int main (void)
{
	int len ,i ;
	int * pArr;

	printf ("请输入你需要定义的数组元素个数：\n");
	scanf("%d",&len);

	pArr=(int)malloc (4*len); // 重要，记住，创建一个动态内存的一维数组

	printf ("\n请输入你需要定义的 %d 个数组元素：\n",len);
	for(i = 0; i < len ;i++)
		scanf("%d",&pArr[i]);

	printf ("\n这里是你定义的 %d 个数组元素：\n",len);
	for(i = 0; i < len ;i++)
		printf("%5d",pArr[i]);


	printf("\nThanks ! \n");

}

	――――――――――――――――――――

		* realloc(数组名pArr,100);

		 //将数组内存调整为100字节，50扩充为100字节的话，50字节的数据保留，再加50字节的内存；但是如果是150字节的内存的话，会将后50字节的数据删除，成为100字节的数组


		4.静态内存和动态内存的比较：

		* 静态内存由系统自动分配并释放，是在栈分配的

		  动态内存是由程序员手动分配并释放，是在堆分配的


		5.跨函数使用内存的问题：

		静态内存不能跨函数使用，否则会出现 内存越界 的情况，只有指针才会出现的情况

		动态内存可以跨函数使用


	――――――――――――――――――――――――

		[2]指针和二维数组




	（3）指针和函数

	（4）指针和结构体（重要）

	（5）多级指针

		int i = 10； int * p = &i；int ** q = &p；int *** r = &q；
		地址：100H	200H		300H		400H

		p 是一个指针变量，存放的是 i 的地址（100H），地址的类型是 int 类型；

		q是个指针的指针，存放的是指针变量 p 的地址（200H），存放的是指针变量 p 的地址，地址类型是int * 类型；

		r是 指针的指针 的指针，存放的是变量 q 的地址（300H），存放的是指针变量的指针 q 的地址，地址类型是 int ** 类型

		他们只能逐级存放上级指针/常数的地址

		*** r == i；

		―――――――――――――――――――――
		|					 |
		|如果，p 是 int * 类型，&p 是 int ** 类型|
		|					 |
		―――――――――――――――――――――

		――――――――――――――――――――――

		int i = 10；
		int * p = &i；//即 p 存放的是 i 的地址

		int ** q = &p；//即 q 存放的是 p 的地址

		则 * q 就是 p ，** q 就是 *p ，也就是 i 

		――||在定义指针时，int * ，int ** ，int *** 等都和 int 的功能类似，都是数据类型，而在此之后的 p ，q ， r 等才是存放相应变量地址的变量||――

		――――――――――――――――――――――


20.结构体

	――――――――――

	struct Sturdent //自定义一个数据类型：struct Student
	{
		int age;
		float score;
		char sex;
	} 
	int main(void)
	{
		struct Student st = {80,66.6,'F'};  //定义了一个 struct Student 类型的变量 st ，并给其赋值

	}

	//66.6等在VC中默认是 double 类型，写成 66.6F 强制转化为 float 类型，但是由于 float 或 double 等浮点数一般不能准确存储数字，有的数据会有误差

	――――――――――

  1）结构体 是用户自定义的数据类型，是基本数据类型的集合体

  2）目的 为了表示一些复杂的事物，更好的模拟现实情况

  3）定义方式

	第一种，先定义，后初始化（推荐使用）：

	struct xx1 {int a；float b；……}；

	struct xx1 a = {8,5.6，……}；

	第二种，定义的同时直接写变量名称，但无法再次用这种数据类型：

	struct xx2 {int a；float b；……} b；

	第三种，变量没有名字

	struct {int a；float b；……} c；

  4）使用

	（1）赋值和初始化

	定义的时候可以连续赋值，但是定义完之后就只能单个赋值，而不能连续赋值

		初始化：

		struct xx1 a = {8,5.6，……}；

		//初始化的时候是可以连续赋值的

		先定义，后赋值：
	
		struct Sturdent st2;

		struct Student *p;

		st2.age = 10;
		st2.score = 88;
		st2.sex = 'F';	

		//定义完之后只能单个赋值

	（2）取出结构体变量中的每一个成员

		结构体变量名.成员名	|st2.age

		指针变量.成员名		|(*p).sex 或者 p->sex（更加常用）

					||pst->sex 的含义是：pst 所指向的结构体变量中 sex 这个成员,pst->sex 在计算机中会被转化为 (*p).sex 

	（3）结构体变量的运算

	不能相互 + - / *

	但，结构体变量可以相互赋值：

		struct Sturdent st1，st2;

		st1 = st2；正确


	（4）结构体变量和结构体变量指针作为函数参数传递的问题

	在输出内容的时候可以使用指针传递（这样只需要传递4个内存），可以减少内存耗用，节约时间，但是需要防止函数修改内容

	（5）动态构造存放学生信息的结构体数组

		动态构造一个数组，存放学生的信息

		并按照分数排序输出
	

	（6）链表：

		是 数据结构 的铺垫

		[1]定义

		――||算法的定义

			通俗：解题的方法和步骤

			狭义：对存储数据的操作

				对不同的存储结构，要完成某一功能要执行的操作时不一样的

				**  算法是依附于存储结构的  **

				**  不同的存储结构所执行的算法是不一样的  **

			广义：也称 泛型

				无论数据如何存储，对其的操作都是一样的

				

		――――――――――――――――――――

		至少有两种方法存储数据：数组 ，链表

			数组：	存取速度快

				如果定义的数组特别大的时候，意味着内存要分配一块连续的大空间，当内存中没有的时候就会分配失败 ；

				当数据中要删除或插入某个数据的效率很低

			链表：	解决了上述问题，不需要一个连续的内存

				链表存储的是不连续的数据，每个小格数据存储了数据和下一个小格数据的地址

				插入，删除，移动元素修改范围小

				缺点：	每次查找数据都得从刚开始查找，效率低；
					而数组可以通过下标快速定位某个元素

		――――――――――――――――――――

		[2]链表的定义

		专业术语：

		头结点： 数据类型和首节点类型完全一样

			是首节点前面的那个节点

			不存放有效数据

			目的是为了方便对链表的操作

		头指针： 存放头结点地址的指针变量

		首节点： 存放第一个有效数据的节点

		尾节点： 存放最后一个有效数据的节点，指针指向为空

			――――――――――――――――

			示意图：

			  O-------O-----……--O
			  |	  |	      |
			头结点-首节点-……-尾节点

			头指针指向头结点，尾节点指向为空

			――――――――――――――――

		确定一个列表需要一个参数： 头指针

		[3]利用头指针（pHead）确定链表是否为空

		bool empty_list(struct Node * pHead)
		{
			if(pHead -> pNext == 'NULL')

				/* pHead -> pNext等价于（*pHead）.pNext

				此语句的作用是判断pHead指向pNext的指针是不是空的					如果是，返回true，否则返回false */ 

				return true ;
			else 
				return  flase ;
		}

		/*下面一段语句的作用是，将链表输出*/

		struct Node * p = pHead -> pNext;  // 把pHead指向的指针域赋值给 p

		while( p != NULL)

		{

			printf ("%d \n",p->data);

			p = p->pNext; 

		}

		[4]


20.枚举

  1）定义

	把一个事物所有可能取值一一列举出来

  2）使用方法

	定义：

	enum WeekDay 
	{
		MonDay,TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay	//注意：这里没有分号！
	};

	赋值：
	
	enum WeekDay day = WednesDay;

  3）规定程序只能从指定的范围内取值，使得代码更加安全

	但是，书写比较麻烦，应用不多

21.补码

  1）定义

	VC++ 6.0 中，int类型变量 可以存储的数字范围是：

	最小负数的二进制代码是：1000 0000 …… 0000 ，其中共7（0000） 等于十六进制 - 0X 8000 0000 即：- 8 * 16^7

								数字超过最大正数的时候会溢出，只能存放最后面的字节

	最大正数的二进制代码是：0111 1111 …… 1111 ，其中共7个（1111） 等于十六进制 0X 7FFF FFFF 

	求已知二进制的整数的十进制是：

	数字超过最大正数会怎么样 溢出

  2）分类

	原码（计算机中没应用）

		也称为：符号-绝对值码

		最高位 0 表示正，1表示负，其余二进制位是该数字的绝对值的二进制位


		简单易懂

		加减运算复杂

		存在+-*/四种运算，增加了CPU复杂度

		0的表示不唯一（正0和负0）

	反码（无应用）

		运算不便，无应用

	移码

		表示数值平移 N 位，N 称为 移码量

		移码主要用于浮点数的阶码的存储

	补码

		高级语言要求不高，但是基础语言对其要求高

		十进制 转 二进制 

			正整数转二进制：除二取余，商为0时，余数倒排

			负整数转二进制：先求对应的正整数二进制，然后所有位取反，末尾加1，不够位数时，左边补1

				――――――――――――――――――――――

				如：-3	：3对应的二进制是011；所有位取反：100；末尾加1:101：；

				不够位数，左边加1：（此处28个1）1101 ；对应的16进制是 0XFFFFFFFD。

				一个整数占4个字节，也就是4*8=32位，101只有3位，故而在前面加上 29个1 

				转成16进制的话 1101对应D，1111（十进制15）对应一个F（十进制15）


				先转化为16进制，再转化为2进制，简单：

				-100	= （64）16进制	= 0110 0100 二进制

				然后取反：1001 1011	末尾加1:1001 1100

				左边加 1 : 6 个（1111）1001 1100	

				对应的16进制：DXFFFF FF9C

				――――――――――――――――――――――

				求零的二进制

					都是零	


		二进制 转 十进制

			首位是 0 ，这是正整数，按普通方法求；

			首位是 1 ，这是负整数，所有位取反，末尾加1，所得数字是该负数绝对值

				――――――――――――――――――――――

				二进制：默认补 0 , int 要补够 32 位

				11101111: 取反：0001 0000 ；末尾加1:0001 0001 

				对应的16进制是11，即就是16*1+1*1=17，所以该负数是-17

				――――――――――――――――――――――
			如果全是 0 ，对应的十进制是 0 。

			――――――――――――――――――――――

			求二进制对应的十进制	二进制|十六进制|十进制

				0000 0001	| 1|	1

				0111 1111	|7F|	7*16+15*1 = 127	

				1000 0000	|取反：0111 1111 ；加1:1000 0000（此时是正数） ；80|	-（8*16+0*1） = - 128

				1000 0001	|取反：0111 1110 ；加1:0111 1111 ；81|  -（7*16+15*1） = - 127

				1111 1111	|取反：0000 0000 ；加1:0000 0001 ；01|	- 1*1 = - 1

					0,1,2，……，127，-128，-127，……，-2，-1

				char ch = ox80 ;printf ("%d",ch);	输出结果：-128

				ch = 128 ；printf("%d",ch);	输出结果是：-128	

				//整型变量128占有4个字节（4*8个0110……），当其赋值给 ch （字符型，占一个字节）时，只剩下最后的一个字节可以存入，即存入的是 1000 0000 ，即就是 -128

				同理； 129 会输出为 -127


			――――――――――――――――――――――


22.位运算

  1）分类

	& ―― 按位与	将两个数字对应的二进制，每一位都相 与 

		&& 逻辑与 ，两个数字相 与

		有 0 就 0

	| ―― 按位或	将两个数字对应的二进制，每一位都相 或

		|| 逻辑或，两数字相 或

		有 1 就 1

	~ ―― 按位取反	将数字对应的二进制，每一位都 取反 ，前面补1

		1 -> 0 ,0 -> 1

	^  ――按位异或 将数字对应的二进制，每一位都：相同为0，不同为1

		0^0 = 0 ; 1^1 = 0 ; 1^0 = 1 ; 0^1 = 1

	<<  ――按位左移 将数字对应的二进制，每一位都左移1位，右边补0

		i << N  左移 N 位，相当于乘以 2^N

		(A)i = i * 8 ;(B)i = i << 3  (B比A速度快，B只移位，A还要调用算法器)

	>>  ――按位右移  将数字对应的二进制，每一位都右移1位，左边一般补0

		i >> N  右移 N 位，相当于除以 2^N ，前提是数据不丢失

  2）功能

	位运算符可以对数据进行精确到 位 的操作

	一般对数据操作只能精确到 某一字节


23.NULL

	数值零

	字符串结束标记' \0 '

	空指针 NULL

		表示编号为 零 的地址

		NULL 表示 零 ，但不是数字 0 ，而是内存单元的编号 零 

		计算机规定：以 零 为编号的存储单元的内容不可读，不可写










